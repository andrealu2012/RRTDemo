# RRT算法演示
![alt text](/image/image-1.png)
一个用于学习和对比多种RRT（Rapidly-exploring Random Tree）路径规划算法的交互式可视化工具。

## 项目简介

本项目实现了5种经典的RRT算法变体，并提供了交互式可视化界面，方便用户直观地理解不同算法的特点和性能差异。

## 功能特点

- 🎯 **5种算法对比**：RRT、RRT*、RRT-Connect、RRT*-Connect、RRT-Connect+Path Shortcutting
- 🖥️ **交互式界面**：一键切换算法显示，实时查看规划结果
- 📊 **性能统计**：显示总节点数、路径节点数、路径长度、计算时间
- 🎲 **随机障碍物生成**：可自定义障碍物数量范围，测试算法鲁棒性
- 🎨 **清晰可视化**：不同颜色显示不同算法的搜索树和路径
- 📝 **中文支持**：完整的中文界面和注释

## 算法说明

### 1. RRT（基础版）
- **特点**：快速探索，找到第一条可行路径即停止
- **优点**：速度快，适合简单场景
- **缺点**：路径通常不是最优的

### 2. RRT*（优化版）
- **特点**：在RRT基础上增加了路径优化机制
- **优点**：生成更短、更平滑的路径
- **缺点**：计算时间相对较长

### 3. RRT-Connect（双向版）
- **特点**：从起点和终点同时生长两棵树，直到连接
- **优点**：通常最快找到路径
- **缺点**：路径质量一般

### 4. RRT*-Connect（混合版）
- **特点**：结合双向搜索和路径优化
- **优点**：平衡速度和路径质量
- **缺点**：实现复杂度较高

### 5. RRT-Connect + Path Shortcutting（后处理优化版）
- **特点**：先用RRT-Connect快速找路径，再进行路径快捷化
- **优点**：速度快且路径质量好，实现简单
- **缺点**：极端情况下可能优化有限

## 环境要求

- Python 3.7+
- numpy
- matplotlib

## 安装

```bash
# 安装依赖
pip install numpy matplotlib

# 或使用conda
conda install numpy matplotlib
```

## 使用方法

### 快速开始

```bash
python visualizer.py
```

### 界面操作

#### 右侧控制区
- **5个算法按钮**：点击切换显示不同算法的结果
  - RRT
  - RRT*
  - RRT-Connect
  - RRT*-Connect
  - RRT-C+Shortcut

- **生成新障碍物按钮**：使用当前设置生成随机障碍物并重新规划

#### 底部控制区
- **最小障碍物滑杆**：设置随机生成障碍物的最小数量（1-15）
- **最大障碍物滑杆**：设置随机生成障碍物的最大数量（1-15）

### 查看结果

主界面会显示：
- 搜索树（浅色线条和节点）
- 规划路径（蓝色粗线）
- 起点（绿色圆点）
- 终点（红色星号）
- 障碍物（灰色矩形）
- 统计信息（左上角文本框）

## 文件结构

```
RRTDemo/
├── rrt_base.py              # RRT基础类
├── rrt_star.py              # RRT*算法
├── rrt_connect.py           # RRT-Connect算法
├── rrt_star_connect.py      # RRT*-Connect算法
├── rrt_connect_shortcut.py  # RRT-Connect+路径快捷算法
├── visualizer.py            # 主程序和可视化界面
└── README.md                # 本文件
```

## 代码架构

- **Node类**：树节点，包含坐标、父节点、代价信息
- **RRT类**：基础RRT算法实现
- **RRTStar类**：继承RRT，增加路径优化
- **RRTConnect类**：继承RRT，实现双向搜索
- **RRTStarConnect类**：继承RRTConnect，结合优化策略
- **RRTConnectShortcut类**：继承RRTConnect，增加路径快捷化
- **InteractiveVisualizer类**：交互式可视化界面

## 自定义参数

编辑 `visualizer.py` 的 `main()` 函数可自定义：

```python
start = (1, 1)              # 起点坐标
goal = (9, 9)               # 终点坐标
obstacles = [...]           # 障碍物列表 (x, y, width, height)
bounds = (0, 10, 0, 10)     # 空间边界 (x_min, x_max, y_min, y_max)
step_size = 0.5             # 扩展步长
max_iter = 2000             # 最大迭代次数
search_radius = 1.5         # RRT*搜索半径
```

## 示例输出

运行后终端会显示类似以下信息：

```
======================================================================
RRT算法全家桶对比演示
======================================================================

[1/5] 运行RRT算法...
开始RRT路径规划...
找到路径！迭代次数: 234
RRT结果: 节点数=234, 路径长度=12.45, 时间=0.156秒

[2/5] 运行RRT*算法...
开始RRT*路径规划...
找到路径！迭代次数: 456
RRT*结果: 节点数=456, 路径长度=11.23, 时间=0.287秒

...

算法对比:
======================================================================
RRT:                     路径长度=12.45, 节点数=234, 时间=0.156秒
RRT*:                    路径长度=11.23, 节点数=456, 时间=0.287秒
RRT-Connect:             路径长度=12.78, 节点数=189, 时间=0.098秒
RRT*-Connect:            路径长度=11.56, 节点数=312, 时间=0.198秒
RRT-Connect+Shortcut:    路径长度=11.34, 节点数=189, 时间=0.112秒

提示: 在可视化窗口中点击按钮可以切换显示不同算法的结果
======================================================================
```

## 学习资源

- **RRT原论文**：S. M. LaValle, "Rapidly-exploring random trees: A new tool for path planning", 1998
- **RRT*论文**：S. Karaman and E. Frazzoli, "Sampling-based algorithms for optimal motion planning", 2011

## 开发说明

本项目专为学习目的设计，代码结构清晰，注释详细，适合：
- 学习路径规划算法
- 理解RRT系列算法原理
- 算法性能对比研究
- 作为课程作业或研究起点

## 技术特点

- **模块化设计**：每个算法独立文件，便于学习和修改
- **继承复用**：通过继承减少代码重复，体现算法演进关系
- **中文友好**：完整的中文注释和界面
- **可扩展性**：易于添加新的算法变体

## 常见问题

**Q: 为什么有时候算法找不到路径？**  
A: 可能是障碍物太密集或max_iter设置太小，可以增大迭代次数或减少障碍物。

**Q: 如何调整算法参数？**  
A: 编辑visualizer.py中的main()函数，修改step_size、max_iter等参数。

**Q: 可以添加新算法吗？**  
A: 可以！继承RRT基类，实现自己的plan()方法，然后在visualizer中添加即可。

**Q: 为什么RRT*比RRT慢？**  
A: RRT*需要在每次添加节点时进行rewire操作，计算量更大，但换来了更优的路径。

## 许可证

本项目仅供学习交流使用。

## 贡献

欢迎提出改进建议！

---

**Happy Learning! 祝学习愉快！** 🚀
